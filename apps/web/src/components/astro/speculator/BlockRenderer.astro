---
import type { Block, Section, BlockHeading, Inline } from '@openuji/speculator';
import InlineRenderer from './InlineRenderer.astro';
import RecursiveBlockRenderer from './BlockRenderer.astro';
import Mermaid from './Mermaid.astro';
import CodeCustom from './CodeCustom.astro';
import type { CodeLanguage } from 'astro';

interface Props {
  node: Block | Section;
  basePath?: string;
  documentPath?: string;
  headingNumbers?: { [k: string]: string | undefined };
}

const { node, basePath, documentPath, headingNumbers } = Astro.props;

// Shared props for InlineRenderer
const inlineProps = { basePath };

// Shared props for recursive BlockRenderer calls
const blockProps = { basePath, documentPath, headingNumbers };

// Helper to determine heading level for section
type HeadingTagName = 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6';

// Helper to determine heading level for section
const getHeadingTag = (node: BlockHeading): HeadingTagName => {
  const level = Math.min(node.depth, 6) as 1 | 2 | 3 | 4 | 5 | 6;
  return `h${level}`;
};

// Get section number for a given section ID
const getSectionNumber = (sectionId?: string): string | undefined => {
  if (!sectionId || !headingNumbers) return undefined;
  return headingNumbers[sectionId];
};
---

{
  (() => {
    switch (node.type) {
      case 'section': {
        // Section logic
        const HeadingTag = node.heading ? getHeadingTag(node.heading) : 'h2'; // fallback
        const sectionNumber = getSectionNumber(node.id);
        return (
          <section id={node.id} class="spec-section">
            {node.heading && (
              <HeadingTag id={node.heading.id} class="section-heading">
                {sectionNumber && <span class="section-number">{sectionNumber}. </span>}
                <InlineRenderer nodes={node.heading.children} {...inlineProps} />
              </HeadingTag>
            )}
            {node.children.map((child) => (
              <RecursiveBlockRenderer node={child} {...blockProps} />
            ))}
          </section>
        );
      }

      case 'paragraph':
        return (
          <p id={node.id}>
            <InlineRenderer nodes={node.children} {...inlineProps} />
          </p>
        );

      case 'heading': {
        const H = getHeadingTag(node);
        return (
          <H id={node.id}>
            <InlineRenderer nodes={node.children} {...inlineProps} />
          </H>
        );
      }

      case 'codeBlock': {
        // Handle Mermaid diagrams
        if (node.lang === 'mermaid') {
          return <Mermaid code={node.value} id={node.id} />;
        }
        // Regular code block
        const codeBlock = (
          <CodeCustom
            id={node.id || undefined}
            code={node.value}
            lang={node.lang as CodeLanguage}
          />
        );
        return codeBlock;
      }

      case 'blockquote':
        return (
          <blockquote id={node.id}>
            {node.children.map((child) => (
              <RecursiveBlockRenderer node={child} {...blockProps} />
            ))}
          </blockquote>
        );

      case 'list': {
        const items = node.children.map((item) => (
          <li>
            {/* ListItem children are Blocks */}
            {item.children.map((child) => (
              <RecursiveBlockRenderer node={child} {...blockProps} />
            ))}
          </li>
        ));

        if (node.ordered) {
          return (
            <ol id={node.id} start={node.start}>
              {items}
            </ol>
          );
        }

        return <ul id={node.id}>{items}</ul>;
      }

      case 'table': {
        const rows = node.children;
        const columnCount = rows[0]?.children.length || 0;
        const hasHeaderRow =
          rows.length > 0 &&
          rows[0].children.length > 0 &&
          rows[0].children.every((cell) => cell.header);
        const headerCells = hasHeaderRow ? rows[0].children : [];
        const bodyRows = hasHeaderRow ? rows.slice(1) : rows;

        return (
          <div class="spec-table-wrap" id={node.id}>
            <table class={`spec-table cols-${columnCount}`}>
              {hasHeaderRow && (
                <thead>
                  <tr>
                    {headerCells.map((cell) => {
                      return (
                        <th>
                          <InlineRenderer nodes={cell.children} {...inlineProps} />
                        </th>
                      );
                    })}
                  </tr>
                </thead>
              )}
              <tbody>
                {bodyRows.map((row) => (
                  <tr>
                    {row.children.map((cell) => {
                      const style = { textAlign: cell.align || 'left' };
                      const content = <InlineRenderer nodes={cell.children} {...inlineProps} />;

                      if (cell.header) {
                        return <th style={style}>{content}</th>;
                      }
                      return <td style={style}>{content}</td>;
                    })}
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        );
      }

      case 'thematicBreak':
        return <hr id={node.id} />;

      case 'html':
        return <div id={node.id} set:html={node.value} />;

      case 'example':
        return (
          <div class="example" id={node.id}>
            {node.title && <div class="example-title">{node.title}</div>}
            <div class="example-content">
              {node.children.map((child) => (
                <RecursiveBlockRenderer node={child} {...blockProps} />
              ))}
            </div>
          </div>
        );

      case 'note': {
        // BlockNote - informative note/warning/example containers
        const noteNode = node as { noteType?: string; children: Block[] } & Block;
        const noteType = noteNode.noteType || 'note';
        const noteClass = `note note-${noteType}`;
        return (
          <aside class={noteClass} id={node.id} role="note">
            <div class="note-header">{noteType.toUpperCase()}</div>
            <div class="note-content">
              {node.children.map((child) => (
                <RecursiveBlockRenderer node={child} {...blockProps} />
              ))}
            </div>
          </aside>
        );
      }

      case 'specStatement': {
        const stmt = node as { level?: string; id?: string; children: Inline[] } & Block;
        const stmtClass = `spec-statement ${stmt.level ? `level-${stmt.level.toLowerCase()}` : ''}`;
        return (
          <p class={stmtClass} id={stmt.id}>
            <InlineRenderer nodes={stmt.children} {...inlineProps} />
          </p>
        );
      }

      default:
        return (
          <div style="border:1px solid red">Unknown block: {(node as { type: string }).type}</div>
        );
    }
  })()
}
